% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibration.R
\name{calibrate}
\alias{calibrate}
\alias{calibrate0}
\title{Perform JER calibration from randomization p-values}
\usage{
calibrate(
  p0,
  alpha,
  family = c("Linear", "Beta", "Simes"),
  m = nrow(p0),
  K = m,
  p = NULL,
  max_steps_down = 10L,
  piv_stat0 = NULL
)

calibrate0(
  p0,
  alpha,
  family = c("Linear", "Beta", "Simes"),
  m = nrow(p0),
  K = m,
  piv_stat0 = NULL
)
}
\arguments{
\item{p0}{A \verb{m x B} matrix. The j-th ow corresponds to a permutation
of the input \code{categ}: for each hypothesis i, \code{p0[i,j]} is the
p-value of the test of the i-th null hypothesis on the permuted categories}

\item{alpha}{A numeric value in \verb{[0,1]}, the target (JER) risk}

\item{family}{A character value, the name of a threshold family. Should be
one of "Linear", "Beta" and "Simes", or "Oracle". "Linear" and "Simes" families are
identical.}

\item{m}{The total numer of tested hypotheses. Defaults to \code{p0}}

\item{K}{An integer value in \verb{[1,m]}, the number of elements in the reference family. Defaults to \code{m}}

\item{p}{A vector of 'm' p.values, used for step-down control. If not
provided, single step control is performed.}

\item{max_steps_down}{A numeric value, the maximum number of steps down to
perform. Defaults to 10 (but the algorithm generally converges in 1 or 2
steps).}

\item{piv_stat0}{Don't use! Should be removed soon...}
}
\value{
A list with elements
\itemize{
\item thr: A numeric vector of length K, such that the estimated probability that
there exists an index k between 1 and K such that the k-th maximum of the
test statistics of is greater than \code{thr[k]}, is less than alpha
\item piv_stat: A vector of \code{B} pivotal statitics
\item lambda: A numeric value, the result of the calibration
}
}
\description{
Perform JER calibration from randomization p-values
}
\details{
'calibrate0' performs single step calibration,
whereas 'calibrate' performs step-down calibration. Hence
the output of 'calibrate(..., max_steps_down = 0)' and
'calibrate0(...)' should be identical
}
\examples{

set.seed(0xBEEF)
m <- 50
n <- 45
X <- matrix(rnorm(m*n), ncol = n, nrow = m)
categ <- rbinom(n, 1, 0.4)
B <- 100
p <- rowWelchTests(X, categ)$p.value

null_groups <- replicate(B, sample(categ))
p0 <- rowWelchTests(X, null_groups)$p.value
calib0 <- calibrate0(p0, alpha = 0.1) # single step
calib <- calibrate(p0, alpha = 0.1)
calib$lambda >= calib0$lambda # probably very close here (null data)

maxFP(p, calib$thr)

\dontrun{
# Gene expression
data(expr_ALL, package = "sansSouci.data")
X <- expr_ALL; rm(expr_ALL)
categ <- ifelse(colnames(X) == "BCR/ABL", 1, 0) # map to 0/1

null_groups <- replicate(500, sample(categ))
perm <- rowWelchTests(X, null_groups)
p0 <- perm$p.value

alpha <- 0.1
calib_L <- calibrate(p0, alpha, family = "Linear")
calib_B <- calibrate(p0, alpha, family = "Beta", K = 100)
p <- rowWelchTests(X, categ)$p.value

## post hoc bounds (these are functions!)
thr <- calib_L$thr
minTP(p, thr)  ## lower bound on true positives


## example of user selection: rejections of BH(0.05) procedure
adjp <- p.adjust(p, method = "BH") 
sel <- which(adjp < 0.05)
length(sel)

minTP(p[sel], thr)

# confidence bound on the FDP
FDP_bound <- sansSouci:::curveMaxFP(sort(p), thr)/seq(along = p)
plot(head(FDP_bound, 300), t = 's', 
  xlab = "Number of features",
  ylab = "Upper bound on False Discovery Proportion")
}

}
\references{
Blanchard, G., Neuvial, P., & Roquain, E. (2020). Post hoc
confidence bounds on false positives using reference families. \emph{Annals of
Statistics}, 48(3), 1281-1303.
}
